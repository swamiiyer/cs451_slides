\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{JVM Code Generation}
\date{}

\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}[fragile]
\pause

Once the AST has been fully analyzed, all variables and expressions have been typed, any necessary tree rewriting has been done, and a certain amount of setup needed for code generation has been accomplished

\pause
\bigskip

The compiler is now ready to traverse the AST one more time to generate the Java Virtual Machine (JVM) code, ie, build the class file for the program

\pause
\bigskip

For example, consider the following very simple program
\begin{lstlisting}[language=Java]
public class Square {
    public int square(int x) {
        return x * x;
    }
}
\end{lstlisting}

\pause
\bigskip

Compiling the program with our \jmm compiler
\begin{lstlisting}[language={}]
$ $j/j--/bin/j-- Square.java
\end{lstlisting}
produces a class file \lstinline{Square.class}

\pause
\bigskip

Running the \lstinline{javap} program on the class file
\begin{lstlisting}[language={}]
$ javap -verbose Square
\end{lstlisting}
produces the symbolic representation of the file shown in the next slide
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]
public class Square extends java.lang.Object
  minor version: 0
  major version: 49
  Constant pool:
const #1 = Asciz    Square;
const #2 = class    #1; //  Square
const #3 = Asciz    java/lang/Object;
const #4 = class    #3; //  java/lang/Object
const #5 = Asciz    <init>;
const #6 = Asciz    ()V;
const #7 = NameAndType  #5:#6;//  "<init>":()V
const #8 = Method   #4.#7;  //  java/lang/Object."<init>":()V
const #9 = Asciz    Code;
const #10 = Asciz   square;
const #11 = Asciz   (I)I;

{
public Square();
  Code:
   Stack=1, Locals=1, Args_size=1
   0: aload_0
   1: invokespecial #8; //Method java/lang/Object."<init>":()V
   4: return

public int square(int);
  Code:
   Stack=2, Locals=2, Args_size=2
   0: iload_1
   1: iload_1
   2: imul
   3: ireturn

}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

To emit JVM instructions, we firstly create a \lstinline{CLEmitter} instance, which is an abstraction of the class file we wish to build, and then call upon \lstinline{CLEmitter}'s methods for generating the necessary headers and instructions

\pause
\bigskip

For example, to generate the class header
\begin{lstlisting}[language=Java]
public class Square extends java.lang.Object
\end{lstlisting}
we would invoke the \lstinline{addClass()} method on \lstinline{output}, an instance of \lstinline{CLEmitter}
\begin{lstlisting}[language=Java]
output.addClass(mods, "Square", "java/lang/Object", null, false);
\end{lstlisting}

\pause
\bigskip

As another example, the no-argument instruction \lstinline{aload_1} may be generated by
\begin{lstlisting}[language=Java]
output.addNoArgInstruction(ALOAD_1);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

For a more involved example of code generation, consider the \lstinline{Factorial} program from before
\begin{lstlisting}[language=Java]
package pass;

import java.lang.System;

public class Factorial {
    // Two methods and a field

    public static int factorial(int n) {
        // position 1:
        if (n <= 0) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

    public static void main(String[] args) {
        int x = n;

        // position 2:
        System.out.println(n + "! = " + factorial(x));
    }

    static int n = 5;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

Running \lstinline{javap} on \lstinline{Factorial.class} produced by the \jmm compiler gives us

\begin{lstlisting}[language={}]
public class pass.Factorial extends java.lang.Object
  minor version: 0
  major version: 49
  Constant pool:
  ...
{
static int n;

public pass.Factorial();
  Code:
   Stack=1, Locals=1, Args_size=1
   0: aload_0
   1: invokespecial #8; //Method java/lang/Object."<init>":()V
   4: return

public static int factorial(int);
  Code:
   Stack=3, Locals=1, Args_size=1
   0: iload_0
   1: iconst_0
   2: if_icmpgt 10
   5: iconst_1
   6: ireturn
   7: goto  19
   10: iload_0
   11: iload_0
   12: iconst_1
   13: isub
   14: invokestatic #13; //Method factorial:(I)I
   17: imul
   18: ireturn
   19: nop
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]


public static void main(java.lang.String[]);
  Code:
   Stack=3, Locals=2, Args_size=1
   0: getstatic #19; //Field n:I
   3: istore_1
   4: getstatic #25; //Field java/lang/System.out:Ljava/io/PrintStream;
   7: new   #27; //class java/lang/StringBuilder
   10: dup
   11: invokespecial    #28; //Method java/lang/StringBuilder."<init>":()V
   14: getstatic    #19; //Field n:I
   17: invokevirtual    #32; //Method java/lang/StringBuilder.append:
                             (I)Ljava/lang/StringBuilder;
   20: ldc  #34; //String ! =
   22: invokevirtual    #37; //Method java/lang/StringBuilder.append:
                             (Ljava/lang/String;)Ljava/lang/StringBuilder;
   25: iload_1
   26: invokestatic #13; //Method factorial:(I)I
   29: invokevirtual    #32; //Method java/lang/StringBuilder.append:
                             (I)Ljava/lang/StringBuilder;
   32: invokevirtual    #41; //Method java/lang/StringBuilder.toString:
                             ()Ljava/lang/String;
   35: invokevirtual    #47; //Method java/io/PrintStream.println:
                             (Ljava/lang/String;)V
   38: return

public static {};
  Code:
   Stack=2, Locals=0, Args_size=0
   0: iconst_5
   1: putstatic #19; //Field n:I
   4: return
}
\end{lstlisting}
\end{frame}

\section{Generating Code for Classes and their Members}
\begin{frame}[fragile]
\pause

\lstinline{JCompilationUnit.codegen()} drives the generation of code for classes; for each type (ie, class) declaration, it
\begin{itemize}
\item invokes \lstinline{codegen()} on the \lstinline{JClassDeclaration} for generating the code for that class,
\item writes out the class to a class file in the destination directory, and
\item adds the in-memory representation of the class to a list that stores such representations for all the classes within a compilation unit; this list is used in translating JVM byte code to native (SPIM) code
\end{itemize}

\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    for (JAST typeDeclaration : typeDeclarations) {
         typeDeclaration.codegen(output);
         output.write();
         clFiles.add(output.clFile());
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\lstinline{JClassDeclaration.codegen()} does the following
\begin{itemize}
\item It computes the fully-qualified name for the class, taking any package name into account
\item It invokes an \lstinline{addClass()} on the \lstinline{CLEmitter} for adding the class header to the start of the class file
\item If there is no explicit constructor with no arguments defined for the class, it invokes the private method \lstinline{codegenImplicitConstructor()} to generate code for the implicit constructor as required by the language
\item It generates code for its members, by sending the \lstinline{codegen()} message to each of them.
\item If there are any static field initializations in the class declaration, then it invokes the private method \lstinline{codegenClassInit()} to generate the code necessary for defining a static block, a block of code that is executed after a class is loaded
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

\lstinline{JMethodDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    output.addMethod(mods, name, descriptor, null, false);
    if (body != null) {
        body.codegen(output);
    }

    // Add implicit RETURN
    if (returnType == Type.VOID) {
        output.addNoArgInstruction(RETURN);
    }
}
\end{lstlisting}

\pause
\bigskip

\lstinline{JConstructorDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    output.addMethod(mods, "<init>", descriptor, null, false);
    if (!invokesConstructor) {
        output.addNoArgInstruction(ALOAD_0);
        output.addMemberAccessInstruction(INVOKESPECIAL,
                ((JTypeDecl) context.classContext().definition())
                        .superType().jvmName(), "<init>", "()V");
    }
    // Field initializations
    for (JFieldDeclaration field : 
             definingClass.instanceFieldInitializations()) {
        field.codegenInitializations(output);
    }
    // And then the body
    body.codegen(output);
    output.addNoArgInstruction(RETURN);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

Since the analysis phase has moved initializations, \lstinline{codegen()} for \lstinline{JFieldDeclaration} need only generate code for the field declaration itself

\pause
\bigskip

\lstinline{JFieldDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    for (JVariableDeclarator decl : decls) {
	// Add field to class
        output.addField(mods, decl.name(), decl.type()
            .toDescriptor(), false);
    }
}
\end{lstlisting}
\end{frame}

\section{Generating Code for Control and Logical Expressions}
\begin{frame}[fragile]
\pause

\end{frame}


\section{Generating Code for Message Expressions, Field Selection, and Array Expressions}
\begin{frame}[fragile]
\pause


\end{frame}

\section{Generating Code for Assignment and Similar Operations}
\begin{frame}[fragile]
\pause


\end{frame}

\section{Generating Code for String Concatenation}
\begin{frame}[fragile]
\pause


\end{frame}

\section{Generating Code for Casts}
\begin{frame}[fragile]
\pause


\end{frame}
\end{document}
