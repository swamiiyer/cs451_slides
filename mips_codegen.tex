\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\usepackage{fancyvrb}

\newcommand{\mm}[1]{$#1$}
\newcommand{\derives}{\stackrel{*}{\Rightarrow}}
\newcommand{\expo}[2]{$#1^{#2}$}
\newcommand{\subs}[2]{${#1}_{#2}$}

\DefineVerbatimEnvironment
{production}{Verbatim}
{fontfamily=timesroman,commandchars=\\\{\}}
\newenvironment{spaced}
{
\smallskip
\hspace{.5cm}
\begin{minipage}[c]{\textwidth}
}
{
\end{minipage}
\smallskip
}

\title{Translating JVM Code to MIPS Code}
\date{}

\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}[fragile]
\pause

Compilation is not necessarily done after the class file is constructed

\pause
\bigskip

At ``execution'', the class is loaded into the JVM and then interpreted

\pause
\bigskip

In the Oracle HotSpot VM, once a method has been executed several times, it is compiled to native code --- code that can be directly executed by the underlying computer

\pause
\bigskip

So at run time, control shifts back and forth between JVM code and native code

\pause
\bigskip

The native code runs much faster than does the interpreted JVM code

\pause
\bigskip

Compiling JVM code to native code involves the following
\begin{itemize}
\item Register allocation
\item Optimization
\item Instruction selection
\item Run-time support
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

We will translate a small subset of JVM instructions to the native code for the MIPS architecture, and execute the native code using SPIM (a MIPS simulator)

\pause
\bigskip

MIPS is a relatively modern reduced instruction set computer (RISC), which has a set of simple but fast instructions that operate on values in registers --- for this reason it is often referred to as a register-based architecture

\pause
\bigskip

Our goal is illustrated in the following figure
\begin{center}
\visible<4->{\includegraphics[scale=0.6]{{figures/figure06.01}.jpg}}
\end{center}

We re-define what constitute the IR, the front end and the back end
\begin{itemize}
\item JVM code is our new IR
\item The \jmm to JVM translator (Chapters 1 --- 5) is our new front end
\item The JVM to SPIM translator (Chapters 6 and 7) is our new back end
\end{itemize}

\pause
\bigskip

We translate enough JVM code to SPIM code to handle the \jmm program shown in the following slide
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language=Java]
import spim.SPIM;

// Prints factorial of a number computed using recursive and iterative
// algorithms.
public class Factorial {
    // Return the factorial of the given number computed recursively.
    public static int computeRec(int n) {
        if (n <= 0) {
            return 1;
        } else {
            return n * computeRec(n - 1);
        }
    }

    // Return the factorial of the given number computed iteratively.
    public static int computeIter(int n) {
        int result = 1;
        while ( n > 0 ) {
            result = result * n--;
	}
        return result;
    }

    // Entry point; print factorial of a number computed using
    // recursive and iterative algorithms.
    public static void main(String[] args) {
        int n = 7;
        SPIM.printInt(Factorial.computeRec(n));
	SPIM.printChar('\n');
        SPIM.printInt(Factorial.computeIter(n));
        SPIM.printChar('\n');
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

We handle static methods, conditional statements, while loops, recursive method invocations, and enough arithmetic to do a few computations

\pause
\bigskip

We must deal with some objects, for example, constant strings

\pause
\bigskip

The program above refers to an array, but doesn't do anything with it so we do not implement array objects

\pause
\bigskip

So, our run-time support is minimal

\pause
\bigskip

To determine what JVM instructions must be handled, it is worth looking at the output from running \lstinline{javap} on \lstinline{Factorial.class}

\pause
\bigskip

\begin{lstlisting}[language={}]
public class Factorial extends java.lang.Object
  minor version: 0
  major version: 49
  Constant pool:
... <the constant pool is elided here> ...

{
public Factorial();
  Code:
   Stack=1, Locals=1, Args_size=1
   0: aload_0
   1: invokespecial #8; //Method java/lang/Object."<init>":()V
   4: return
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]

public static int computeRec(int);
  Code:
   Stack=3, Locals=1, Args_size=1
   0: iload_0
   1: iconst_0
   2: if_icmpgt 10
   5: iconst_1
   6: ireturn
   7: goto  19
   10: iload_0
   11: iload_0
   12: iconst_1
   13: isub
   14: invokestatic #13; //Method computeRec:(I)I
   17: imul
   18: ireturn
   19: nop

public static int computeIter(int);
  Code:
   Stack=2, Locals=2, Args_size=1
   0: iconst_1
   1: istore_1
   2: iload_0
   3: iconst_0
   4: if_icmple 17
   7: iload_1
   8: iload_0
   9: iinc  0, -1
   12: imul
   13: istore_1
   14: goto 2
   17: iload_1
   18: ireturn
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]

public static void main(java.lang.String[]);
  Code:
   Stack=1, Locals=2, Args_size=1
   0: bipush    7
   2: istore_1
   3: iload_1
   4: invokestatic  #13; //Method computeRec:(I)I
   7: invokestatic  #22; //Method spim/SPIM.printInt:(I)V
   10: bipush   10
   12: invokestatic #26; //Method spim/SPIM.printChar:(C)V
   15: iload_1
   16: invokestatic #28; //Method computeIter:(I)I
   19: invokestatic #22; //Method spim/SPIM.printInt:(I)V
   22: bipush   10
   24: invokestatic #26; //Method spim/SPIM.printChar:(C)V
   27: return
}
\end{lstlisting}
\end{frame}

\section{SPIM and the MIPS Architecture}
\begin{frame}[fragile]
\pause

The MIPS computer organization is shown below
\begin{center}
\visible<2->{\includegraphics[scale=0.6]{{figures/figure06.02}.jpg}}
\end{center}
\end{frame}

\begin{frame}[fragile]
\pause

Memory organization, by convention divided into four segments, is shown below
\begin{center}
\visible<2->{\includegraphics[scale=0.5]{{figures/figure06.03}.jpg}}
\end{center}

\begin{itemize}
\item Text segment - The program's instructions go here
\item Static data segment - Static data, which exist for the duration of the program, go here
\item Dynamic data segment (aka heap) - This is where objects and arrays are dynamically
allocated during execution of the program
\item Like the stack for the JVM, every time a routine is called, a new stack frame is pushed onto the stack; every time a return is executed, a frame is popped off
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

Many of the thirty two (0 -- 31) 32-bit general-purpose registers, by convention are designated for special uses, and have alternative names
\begin{itemize}
\item \$zero (0) always holds the constant 0
\item \$at (1)  is reserved for use by the assembler
\item \$v0 and \$v1 (2 and 3) are used for expression evaluation and as the results of a function
\item \$a0 -- \$a3 (4 -- 7) are used for passing the first four arguments to routines; any additional
arguments are passed on the stack
\item \$t0 -- \$t7 (8 -- 15) are meant to hold temporary values that need not be preserved across
routine calls; if they must be preserved, it is up to the caller to save them
\item \$s0 -- \$s7 (16 -- 23) are meant to hold values that must be preserved across routine calls; it is up to the callee to save these registers
\item \$t8 and \$t9 (24 and 25) are caller-saved temporaries
\item \$k0 and \$k1 (26 and 27) are reserved for use by the operating system kernel
\item \$gp (28) is a global pointer to the middle of a 64K block of memory in the static data segment
\item \$sp (29) is the stack pointer, pointing to the last location on the stack
\item \$fp (30) is the stack frame pointer, pointing to the latest frame on the stack
\item \$ra (31) is the return address register, holding the address to which execution should continue upon return from the latest routine
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

SPIM assumes we follow a particular protocol in implementing routine calls, when one
routine (the caller) invokes another routine (the callee)

\pause
\bigskip

Most bookkeeping for routine invocation is recorded in a stack frame on the run-time stack segment, as is done in the JVM; but here we must also deal with registers

\pause
\bigskip

The stack frame for an invoked routine is shown below
\begin{center}
\visible<4->{\includegraphics[scale=0.4]{{figures/figure06.04}.jpg}}
\end{center}

\pause
\bigskip

SPIM provides a set of system calls for accessing simple input and output functions
\end{frame}

\section{Our Translator}
\begin{frame}[fragile]
\pause

Phases of our JVM to SPIM translator are shown below
\begin{center}
\visible<2->{\includegraphics[scale=0.6]{{figures/figure06.06}.jpg}}
\end{center}

\pause
\bigskip

The first step is to scan through the JVM instructions and construct a flow graph of basic blocks

\pause
\bigskip

A basic block is a sequence of instructions with just one entry point at the start and one exit point at the end; otherwise, there are no branches into or out of the instruction sequence
\end{frame}

\begin{frame}[fragile]
\pause

Consider the \lstinline{computeIter()} method from our \lstinline{Factorial} example 
\begin{lstlisting}[language=Java]
    public static int computeIter(int n) {
        int result = 1;
        while ( n > 0 ) {
            result = result * n--;
        }
        return result;
    }
\end{lstlisting}

\pause
\bigskip

The JVM code for the method is shown below (line breaks to delineate basic blocks)
\begin{lstlisting}[language={}]
public static int computeIter(int);
  Code:
   Stack=2, Locals=2, Args_size=1

   0: const_1
   1: istore_1

   2: iload_0
   3: iconst_0
   4: if_icmple 17

   7: iload_1
   8: iload_0
   9: iinc  0, -1
   12: imul
   13: istore_1
   14: goto 2

   17: iload_1
   18: ireturn
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

The control-flow graph, expressed as a graph constructed from the basic blocks is shown below
\begin{center}
\visible<2->{\includegraphics[scale=0.4]{{figures/figure06.07}.jpg}}
\end{center}
\end{frame}

\begin{frame}[fragile]
\pause

The boxes represent the basic blocks and the arrows indicate the flow of control among the blocks

\pause
\bigskip

The first line of text within each box identifies the block, a list of any successor blocks (labeled by \lstinline{succ}) and a list of any predecessor blocks (labeled by \lstinline{pred})

\pause
\bigskip

We add an extra beginning block \lstinline{B0} for the method's entry point

\pause
\bigskip

The denotation \lstinline{[LH]} on the first line of \lstinline{B2} indicates that \lstinline{B2} is a loop header

\pause
\bigskip

The denotation \lstinline{[LT]} on the first line of \lstinline{B3} indicates that \lstinline{B3} is a loop tail

\pause
\bigskip

The pairs of numbers within square brackets, for example \lstinline{[7, 14]} on the first line of \lstinline{B3}, denote the ranges of JVM instructions captured in the block

\pause
\bigskip

The denotation \lstinline{dom} labels the basic block's immediate dominator

\pause
\bigskip

A node $d$ is said to dominate a node $n$ if every path from the entry node (\lstinline{B0}) to $n$ must go through $d$

\pause
\bigskip

A node $d$ strictly dominates $n$ if it dominates $n$ but is not the same as $n$

\pause
\bigskip

Node $d$ is an immediate dominator of node $n$ if $d$ strictly dominates $n$ but does not dominate any other node that strictly dominates $n$, ie, it is the node on the path from the entry node to $n$ that is the ``closest'' to $n$
\end{frame}

\begin{frame}[fragile]
\pause

Local variables are tracked in a state vector called \lstinline{Locals} and are indexed in this vector
by their location in the JVM stack frame

\pause
\bigskip

The current state of this vector at the end of a block's instruction sequence is printed on the block's second line and labeled with \lstinline{Locals}

\pause
\bigskip

The values are listed in positional order and each value is represented by the instruction ID for the instruction that computes it

\pause
\bigskip

For example, in \lstinline{B0} this vector has just one element, corresponding to the method's formal argument \lstinline{n}; in \lstinline{B1} the vector has two elements: the first is \lstinline{I0} for \lstinline{n} and the second is \lstinline{I2} for result

\pause
\bigskip

The instruction sequence within each basic block is of a higher level than is JVM code

\pause
\bigskip

For example, the \jmm statement 
\begin{lstlisting}[language=Java]
w = x + y + z;
\end{lstlisting}
\noindent might bre represented in HIR by
\begin{lstlisting}[language={}]
I8: I0 + I1
I9: I8 + I2
\end{lstlisting}
where \lstinline{I0}, \lstinline{I1} and \lstinline{I2} refer to the instruction IDs labeling instructions that compute values for \lstinline{x}, \lstinline{y} and \lstinline{z} respectively
\end{frame}

\begin{frame}[fragile]
\pause

The instruction for loading a constant is simply the constant itself; for example, the single instruction from block \lstinline{B1} 
\begin{lstlisting}[language={}]
I2: 1
\end{lstlisting}

\pause
\bigskip

Not all instructions generate values; for example, the instruction
\begin{lstlisting}[language={}]
6: if I3 <= I5 then B4 else B3
\end{lstlisting}
\noindent in block \lstinline{B2} produces no value but transfers control to either \lstinline{B4} or \lstinline{B3}
\end{frame}

\begin{frame}[fragile]
\pause

Our HIR employs static single assignment (SSA) form, where for every variable, there is just one place in the method where that variable is assigned a value, which means that when a variable is re-assigned in the method, one must create a new version for it

\pause
\bigskip

For example, given the simple sequence
\begin{lstlisting}[language=Java]
x = 3;
x = x + y;
\end{lstlisting}
we might subscript our variables to distinguish different versions
\begin{production}
\subs{\text{\lstinline{x}}}{\text{1}} \lstinline{= 3;}
\subs{\text{\lstinline{x}}}{\text{2}} \lstinline{=} \subs{\text{\lstinline{x}}}{\text{1}} \lstinline{+} \subs{\text{\lstinline{y}}}{\text{1}}\lstinline{;}
\end{production}

\pause
\bigskip

In the HIR we represent a variable's value by the instruction that computed it and we track these values in the state vector

\pause
\bigskip

The value in a state vector's element may change as we sequence through the block's instructions

\pause
\bigskip

If the next block has just one predecessor, it can copy the predecessor's state vector at its start; if there are two or more predecessors, the states must be merged
\end{frame}

\begin{frame}[fragile]
\pause

For example, consider the following \jmm method, where the variables are in SSA form.
\begin{production}
\lstinline{static int ssa(int} \subs{\text{\lstinline{w}}}{\text{1}}\lstinline{) \{}
    \lstinline{if (}\subs{\text{\lstinline{w}}}{\text{1}} \lstinline{\> 0) \{}
        \subs{\text{\lstinline{w}}}{\text{2}} \lstinline{= 1;}
    \lstinline{\}}
    \lstinline{else \{}
        \subs{\text{\lstinline{w}}}{\text{3}} \lstinline{= 2;}
    \lstinline{\}}
    \lstinline{return} \subs{\text{\lstinline{w}}}{\text{?}}\lstinline{;}
\lstinline{\}}
\end{production}

\pause
\bigskip

In the statement 
\begin{production}
\lstinline{return} \subs{\text{\lstinline{w}}}{\text{?}}\lstinline{;}
\end{production}
which \lstinline{w} do we return?

\pause
\bigskip

We solve this problem by using what is called a Phi function, a special HIR instruction that captures the possibility of a variable having one of several values; in our example, the final block would contain the following code
\begin{production}
\subs{\text{\lstinline{w}}}{\text{4}} = [\subs{\text{\lstinline{w}}}{\text{2}}  \subs{\text{\lstinline{w}}}{\text{3}}];
\lstinline{return} \subs{\text{\lstinline{w}}}{\text{4}}\lstinline{;}
\end{production}
\end{frame}

\begin{frame}[fragile]
\pause

Another place where Phi functions are needed are in loop headers, basic blocks having at least one incoming backward branch and at least two predecessors, as illustrated below

\begin{center}
\visible<2->{\includegraphics[scale=0.5]{{figures/figure06.11}.jpg}}
\end{center}
\end{frame}

\begin{frame}[fragile]
\pause

We conservatively define Phi functions for all variables and then remove redundant Phi functions later

\pause
\bigskip

In the first instance, $\text{\lstinline{w}}_2$ can be defined as a Phi function with operands $\text{\lstinline{w}}_1$  and $\text{\lstinline{w}}_2$
\begin{production}
\subs{\text{\lstinline{w}}}{\text{2}}  = [\subs{\text{\lstinline{w}}}{\text{1}} \subs{\text{\lstinline{w}}}{\text{2}}]
\end{production}

\pause
\bigskip

When \lstinline{w} is later incremented, the second operand may be overwritten by the new $\text{\lstinline{w}}_3$
\begin{production}
\subs{\text{\lstinline{w}}}{\text{2}} = [\subs{\text{\lstinline{w}}}{\text{1}} \subs{\text{\lstinline{w}}}{\text{3}}]
\end{production}

\pause

A redundant Phi function will not be changed and can be removed

\pause
\bigskip

If the \lstinline{w} is never modified in the loop body, the Phi function instruction takes the form
\begin{production}
\subs{\text{\lstinline{w}}}{\text{2}} = [\subs{\text{\lstinline{w}}}{\text{1}} \subs{\text{\lstinline{w}}}{\text{2}}]
\end{production}

\pause
\bigskip

Phi functions are tightly bound to state vectors, so when a block is processed
\begin{itemize}
\item If the block has just a single predecessor, then it may inherit the state vector of that predecessor; the states are simply copied
\item If the block has more than one predecessor, then those states in the vectors that differ must be merged using Phi functions
\item For loop headers we conservatively create Phi functions for all variables, and then later remove redundant Phi functions
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

The translation process from JVM instructions to HIR takes place in the constructor \lstinline{NEmitter()} in the class \lstinline{NEmitter}; for each method, the control-flow graph HIR is constructed in several steps

\pause
\bigskip

The \lstinline{NControlFlowGraph} constructor is invoked on the method, which produces the control-flow graph \lstinline{cfg}; in this first step, the JVM code is translated to sequences of tuples

\begin{enumerate}
\item Objects of type \lstinline{NBasicBlock} represent the basic blocks in the control-flow graph; the control flow is captured by the links, \lstinline{successors} in each block; there are also the links \lstinline{predecessors} for analysis

\item The JVM code is first translated to a list of tuples, corresponding to the JVM instructions; each block stores its sequence of tuples in an \lstinline{ArrayList} called \lstinline{tuples}
\end{enumerate}

\pause
\bigskip

The method call
\begin{lstlisting}[language=Java]
cfg.detectLoops(cfg.basicBlocks.get(0), null);
\end{lstlisting}
detects loop headers and loop tails

\pause
\bigskip

The method call
\begin{lstlisting}[language=Java]
cfg.removeUnreachableBlocks();
\end{lstlisting}
removes unreachable blocks
\end{frame}

\begin{frame}[fragile]
\pause

The method call
\begin{lstlisting}[language=Java]
cfg.computeDominators(cfg.basicBlocks.get(0), null);
\end{lstlisting}
computes an immediate dominator for each basic block, that closest predecessor through which all paths must pass to reach the target block; it's a useful place to which insert invariant code that is lifted out of a loop in optimization

\pause
\bigskip

The method call
\begin{lstlisting}[language=Java]
cfg.tuplesToHir();
\end{lstlisting}
converts the tuples representation to HIR, stored as a sequence of HIR instructions in the array list \lstinline{hir} for each block

\pause
\bigskip

The method call
\begin{lstlisting}[language=Java]
cfg.eliminateRedundantPhiFunctions();
\end{lstlisting}
eliminates unnecessary Phi functions and replaces them with their simpler values

\pause
\bigskip

The HIR is now ready for further analysis
\end{frame}
\end{document}
