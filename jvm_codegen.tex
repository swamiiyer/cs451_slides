\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{JVM Code Generation}
\date{}

\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}[fragile]
\pause

Once the AST has been fully analyzed, all variables and expressions have been typed, any necessary tree rewriting has been done, and a certain amount of setup needed for code generation has been accomplished

\pause
\bigskip

The compiler is now ready to traverse the AST one more time to generate the Java Virtual Machine (JVM) code, ie, build the class file for the program

\pause
\bigskip

For example, consider the following very simple program
\begin{lstlisting}[language=Java]
public class Square {
    public int square(int x) {
        return x * x;
    }
}
\end{lstlisting}

\pause
\bigskip

Compiling the program with our \jmm compiler
\begin{lstlisting}[language={}]
$ $j/j--/bin/j-- Square.java
\end{lstlisting}
produces a class file \lstinline{Square.class}

\pause
\bigskip

Running the \lstinline{javap} program on the class file
\begin{lstlisting}[language={}]
$ javap -verbose Square
\end{lstlisting}
produces the symbolic representation of the file shown in the next slide
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]
public class Square extends java.lang.Object
  minor version: 0
  major version: 49
  Constant pool:
const #1 = Asciz    Square;
const #2 = class    #1; //  Square
const #3 = Asciz    java/lang/Object;
const #4 = class    #3; //  java/lang/Object
const #5 = Asciz    <init>;
const #6 = Asciz    ()V;
const #7 = NameAndType  #5:#6;//  "<init>":()V
const #8 = Method   #4.#7;  //  java/lang/Object."<init>":()V
const #9 = Asciz    Code;
const #10 = Asciz   square;
const #11 = Asciz   (I)I;

{
public Square();
  Code:
   Stack=1, Locals=1, Args_size=1
   0: aload_0
   1: invokespecial #8; //Method java/lang/Object."<init>":()V
   4: return

public int square(int);
  Code:
   Stack=2, Locals=2, Args_size=2
   0: iload_1
   1: iload_1
   2: imul
   3: ireturn

}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

To emit JVM instructions, we firstly create a \lstinline{CLEmitter} instance, which is an abstraction of the class file we wish to build, and then call upon \lstinline{CLEmitter}'s methods for generating the necessary headers and instructions

\pause
\bigskip

For example, to generate the class header
\begin{lstlisting}[language=Java]
public class Square extends java.lang.Object
\end{lstlisting}
we would invoke the \lstinline{addClass()} method on \lstinline{output}, an instance of \lstinline{CLEmitter}
\begin{lstlisting}[language=Java]
output.addClass(mods, "Square", "java/lang/Object", null, false);
\end{lstlisting}

\pause
\bigskip

As another example, the no-argument instruction \lstinline{aload_1} may be generated by
\begin{lstlisting}[language=Java]
output.addNoArgInstruction(ALOAD_1);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

For a more involved example of code generation, consider the \lstinline{Factorial} program from before
\begin{lstlisting}[language=Java]
package pass;

import java.lang.System;

public class Factorial {
    // Two methods and a field

    public static int factorial(int n) {
        // position 1:
        if (n <= 0) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

    public static void main(String[] args) {
        int x = n;

        // position 2:
        System.out.println(n + "! = " + factorial(x));
    }

    static int n = 5;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

Running \lstinline{javap} on \lstinline{Factorial.class} produced by the \jmm compiler gives us

\begin{lstlisting}[language={}]
public class pass.Factorial extends java.lang.Object
  minor version: 0
  major version: 49
  Constant pool:
  ...
{
static int n;

public pass.Factorial();
  Code:
   Stack=1, Locals=1, Args_size=1
   0: aload_0
   1: invokespecial #8; //Method java/lang/Object."<init>":()V
   4: return

public static int factorial(int);
  Code:
   Stack=3, Locals=1, Args_size=1
   0: iload_0
   1: iconst_0
   2: if_icmpgt 10
   5: iconst_1
   6: ireturn
   7: goto  19
   10: iload_0
   11: iload_0
   12: iconst_1
   13: isub
   14: invokestatic #13; //Method factorial:(I)I
   17: imul
   18: ireturn
   19: nop
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\begin{lstlisting}[language={}]


public static void main(java.lang.String[]);
  Code:
   Stack=3, Locals=2, Args_size=1
   0: getstatic #19; //Field n:I
   3: istore_1
   4: getstatic #25; //Field java/lang/System.out:Ljava/io/PrintStream;
   7: new   #27; //class java/lang/StringBuilder
   10: dup
   11: invokespecial    #28; //Method java/lang/StringBuilder."<init>":()V
   14: getstatic    #19; //Field n:I
   17: invokevirtual    #32; //Method java/lang/StringBuilder.append:
                             (I)Ljava/lang/StringBuilder;
   20: ldc  #34; //String ! =
   22: invokevirtual    #37; //Method java/lang/StringBuilder.append:
                             (Ljava/lang/String;)Ljava/lang/StringBuilder;
   25: iload_1
   26: invokestatic #13; //Method factorial:(I)I
   29: invokevirtual    #32; //Method java/lang/StringBuilder.append:
                             (I)Ljava/lang/StringBuilder;
   32: invokevirtual    #41; //Method java/lang/StringBuilder.toString:
                             ()Ljava/lang/String;
   35: invokevirtual    #47; //Method java/io/PrintStream.println:
                             (Ljava/lang/String;)V
   38: return

public static {};
  Code:
   Stack=2, Locals=0, Args_size=0
   0: iconst_5
   1: putstatic #19; //Field n:I
   4: return
}
\end{lstlisting}
\end{frame}

\section{Generating Code for Classes and their Members}
\begin{frame}[fragile]
\pause

\lstinline{JCompilationUnit.codegen()} drives the generation of code for classes; for each type (ie, class) declaration, it
\begin{itemize}
\item invokes \lstinline{codegen()} on the \lstinline{JClassDeclaration} for generating the code for that class,
\item writes out the class to a class file in the destination directory, and
\item adds the in-memory representation of the class to a list that stores such representations for all the classes within a compilation unit; this list is used in translating JVM byte code to native (SPIM) code
\end{itemize}

\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    for (JAST typeDeclaration : typeDeclarations) {
         typeDeclaration.codegen(output);
         output.write();
         clFiles.add(output.clFile());
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

\lstinline{JClassDeclaration.codegen()} does the following
\begin{itemize}
\item It computes the fully-qualified name for the class, taking any package name into account
\item It invokes an \lstinline{addClass()} on the \lstinline{CLEmitter} for adding the class header to the start of the class file
\item If there is no explicit constructor with no arguments defined for the class, it invokes the private method \lstinline{codegenImplicitConstructor()} to generate code for the implicit constructor as required by the language
\item It generates code for its members, by sending the \lstinline{codegen()} message to each of them.
\item If there are any static field initializations in the class declaration, then it invokes the private method \lstinline{codegenClassInit()} to generate the code necessary for defining a static block, a block of code that is executed after a class is loaded
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\pause

\lstinline{JMethodDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    output.addMethod(mods, name, descriptor, null, false);
    if (body != null) {
        body.codegen(output);
    }

    // Add implicit RETURN
    if (returnType == Type.VOID) {
        output.addNoArgInstruction(RETURN);
    }
}
\end{lstlisting}

\pause
\bigskip

\lstinline{JConstructorDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    output.addMethod(mods, "<init>", descriptor, null, false);
    if (!invokesConstructor) {
        output.addNoArgInstruction(ALOAD_0);
        output.addMemberAccessInstruction(INVOKESPECIAL,
                ((JTypeDecl) context.classContext().definition())
                        .superType().jvmName(), "<init>", "()V");
    }
    // Field initializations
    for (JFieldDeclaration field : 
             definingClass.instanceFieldInitializations()) {
        field.codegenInitializations(output);
    }
    // And then the body
    body.codegen(output);
    output.addNoArgInstruction(RETURN);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

Since the analysis phase has moved initializations, \lstinline{codegen()} for \lstinline{JFieldDeclaration} need only generate code for the field declaration itself

\pause
\bigskip

\lstinline{JFieldDeclaration.codegen()}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    for (JVariableDeclarator decl : decls) {
	// Add field to class
        output.addField(mods, decl.name(), decl.type()
            .toDescriptor(), false);
    }
}
\end{lstlisting}
\end{frame}

\section{Generating Code for Control and Logical Expressions}
\begin{frame}[fragile]
\pause

Almost all control statements in \jmm are controlled by some Boolean expression

\pause
\bigskip

For example, consider the if-then-else statement below
\begin{lstlisting}[language=Java]
if (a > b) { c = a; } else { c = b; }
\end{lstlisting}

The JVM code produced for the statement is as follows
\begin{lstlisting}[language={}]
0: iload_1
1: iload_2
2: if_icmple 10
5: iload_1
6: istore_3
7: goto  12
10: iload_2
11: istore_3
12: ...
\end{lstlisting}

\pause
\bigskip

Notice a couple of things
\begin{enumerate}
\item We don't compute a Boolean value onto the stack and then branch on its value, but make use of the underlying JVM instruction set, which makes for more compact code

\item We branch to the else-part if the condition is \lstinline{false}
\begin{lstlisting}[language={}]
branch to elseLabel if <condition> is false
    <code for thenPart>
    branch to endLabel
elseLabel:
    <code for elsePart>
endLabel:
\end{lstlisting}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\pause

Suppose we wish implement the Java do-while statement in \jmm; for example
\begin{lstlisting}[language=Java]
do {
    a++;
}
while (a < b);
\end{lstlisting}

The code we generate might have the form
\begin{lstlisting}[language={}]
topLabel:
    <code for body>
    branch to topLabel if <condition> is true
\end{lstlisting}

Note that we branch when the condition is \lstinline{true}

\pause
\bigskip

In generating code for a condition, one needs a method specifying three arguments
\begin{enumerate}
\item The \lstinline{CLEmitter} instance
\item The target label for the branch
\item A \lstinline{boolean} flag \lstinline{onTrue}; if \lstinline{onTrue} is \lstinline{true} then the branch should be made on the condition, and if \lstinline{false}, the branch should be made on the condition's complement
\end{enumerate}

\pause
\bigskip

Thus, every boolean expression must support a version of \lstinline{codegen()} with these three arguments;  for example, here is that overloaded \lstinline{codegen()} method for \lstinline{JGreaterThanOp}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output, String targetLabel, boolean onTrue) {
    lhs.codegen(output);
    rhs.codegen(output);
    output.addBranchInstruction(onTrue ? IF_ICMPGT : IF_ICMPLE, targetLabel);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

The three-argument \lstinline{codegen()} method is invoked on the condition controlling execution

\pause
\bigskip

For example, the \lstinline{codegen()} method in \lstinline{JIfStatement} makes use of the three-argument \lstinline{codegen()} method in producing code for the if-then-else statement
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output) {
    String elseLabel = output.createLabel();
    String endLabel = output.createLabel();
    condition.codegen(output, elseLabel, false);
    thenPart.codegen(output);
    if (elsePart != null) {
        output.addBranchInstruction(GOTO, endLabel);
    }
    output.addLabel(elseLabel);
    if (elsePart != null) {
        elsePart.codegen(output);
        output.addLabel(endLabel);
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

The semantics of Java, and so of \jmm, requires that the evaluation of expressions such as \lstinline{arg1 && arg2} be short-circuited, ie, if \lstinline{arg1} is \lstinline{false}, then \lstinline{arg2} is not evaluated

\pause
\bigskip

The code to be generated depends of whether the branch for the entire expression is to be made on \lstinline{true}, or on \lstinline{false}

\begin{lstlisting}[language={}]
Branch to target when           Branch to target when
    arg1 && arg2 is true:                arg1 && arg2 is false:

    branch to skip if               branch to target if
        arg1 is false                    arg1 is false
    branch to target when           branch to target if
        arg2 is true                     arg2 is false
skip: ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

For example, the code generated for 
\begin{lstlisting}[language=Java]
if (a > b && b > c) { c = a; } else { c = b; }
\end{lstlisting}

would be

\begin{lstlisting}[language={}]
0: iload_1
1: iload_2
2: if_icmple 15
5: iload_2
6: iload_3
7: if_icmple 15
10: iload_1
11: istore_3
12: goto 17
15: iload_2
16: istore_3
17: ...
\end{lstlisting}

\pause
\bigskip

The \lstinline{codegen()} method in \lstinline{JLogicalAndOp}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output, String targetLabel, boolean onTrue) {
    if (onTrue) {
        String falseLabel = output.createLabel();
        lhs.codegen(output, falseLabel, false);
        rhs.codegen(output, targetLabel, true);
        output.addLabel(falseLabel);
    } else {
        lhs.codegen(output, targetLabel, false);
        rhs.codegen(output, targetLabel, false);
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

Notice that our method prevents unnecessary branches to branches; for example, consider the slightly more complicated condition in
\begin{lstlisting}[language=Java]
if (a > b && b > c && c > 5) { c = a; } else { c = b; }

\end{lstlisting}

The JVM code produced for this targets the same exit on \lstinline{false}, for each of the \lstinline{&&} operations
\begin{lstlisting}[language={}]
0:   iload_1
1:   iload_2
2:   if_icmple       18
5:   iload_2
6:   iload_3
7:   if_icmple       18
10:  iload_3
11:  iconst_5
12:  if_icmple       18
15:  iinc    1, -1
18:  ...
\end{lstlisting}

\pause
\bigskip

The \lstinline{codegen()} method in \lstinline{JLogicalNotOp}
\begin{lstlisting}[language=Java]
public void codegen(CLEmitter output, String targetLabel, boolean onTrue) {
    arg.codegen(output, targetLabel, !onTrue);
}
\end{lstlisting}
\end{frame}

\section{Generating Code for Message Expressions, Field Selection, and Array Expressions}
\begin{frame}[fragile]
\pause

The \lstinline{codegen()} method in \lstinline{JMessageExpression} proceeds as follows
\begin{enumerate}
\item If the message expression involves an instance message, \lstinline{codegen()} generates code for the target
\item The message invocation instruction is determined: \lstinline{invokevirtual} for instance messages and \lstinline{invokestatic} for static messages
\item The \lstinline{addMemberAccessInstruction()} method is invoked to generate the message invocation instruction; this method takes the following arguments
\begin{enumerate}[(a)]
\item The instruction (\lstinline{invokevirtual} or \lstinline{invokestatic})
\item The JVM name for the target's type
\item The message name
\item The descriptor of the invoked method, which was determined in analysis.
\end{enumerate}
\item If the message expression is being used as a statement expression and the return type of the method  is non-void, then the method \lstinline{addNoArgInstruction()} is invoked for generating a \lstinline{pop} instruction; this is necessary because executing the message expression will produce a result on top of the stack, and this result is to be thrown away
\end{enumerate}
\end{frame}

\section{Generating Code for Assignment and Similar Operations}
\begin{frame}[fragile]
\pause

For example, the code generated for 
\begin{lstlisting}[language=Java]
... = s.square(6);
\end{lstlisting}
would be
\begin{lstlisting}[language={}]
aload s' # s' denotes offset of s
bipush  6
invokevirtual   #6; //Method square:(I)I
\end{lstlisting}

whereas the code generated for 
\begin{lstlisting}[language=Java]
s.square(6);
\end{lstlisting}
would be 
\begin{lstlisting}[language={}]
aload s'
bipush  6
invokevirtual   #6; //Method square:(I)I
pop
\end{lstlisting}

\pause
\bigskip

We invoke static methods using the \lstinline{invokestatic} instruction; for example the following \jmm code
\begin{lstlisting}[language=Java]
... = Square.square(5);
\end{lstlisting}
where \lstinline{int square(int)} is a static method in \lstinline{Square}, would generate the following JVM code
\begin{lstlisting}[language={}]
iconst_5
invokestatic    #5; //Method square:(I)I
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause

The \lstinline{codegen()} method in \lstinline{JFieldSelection} works as follows
\begin{enumerate}
\item It generates code for its target; if the target is a class, no code is generated
\item The compiler must again treat the special case, \lstinline{a.length} where \lstinline{a} is an array; the code generated makes use of the special instruction, \lstinline{arraylength}
\item Otherwise, it is treated as a proper field selection; the field selection instruction is determined: \lstinline{getfield} for instance fields and \lstinline{getstatic} for static fields
\item The \lstinline{addMemberAccessInstruction()} method is invoked with the following arguments
\begin{enumerate}[(a)]
\item The instruction (\lstinline{getfield} or \lstinline{getstatic})
\item The JVM name for the target's type
\item The field name
\item The JVM descriptor for the type of the field, and so the type of the result
\end{enumerate}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\pause

For example, the following code
\begin{lstlisting}[language=Java]
... = s.instanceField;
\end{lstlisting}
would be translated as
\begin{lstlisting}[language={}]
aload s'
getfield instanceField
\end{lstlisting}

whereas the following code
\begin{lstlisting}[language=Java]
... = Square.staticField;
\end{lstlisting}
would be translated as
\begin{lstlisting}[language={}]
getstatic staticField
\end{lstlisting}

\pause
\bigskip

Code generation for array access expressions is straightforward; for example, if the variable \lstinline{a} references an array object, and \lstinline{i} is an integer, then the following code
\begin{lstlisting}[language=Java]
... = a[i];
\end{lstlisting}
is translated to 
\begin{lstlisting}[language={}]
aload a'
iload i'
iaload
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\pause


\end{frame}

\section{Generating Code for String Concatenation}
\begin{frame}[fragile]
\pause


\end{frame}

\section{Generating Code for Casts}
\begin{frame}[fragile]
\pause


\end{frame}
\end{document}
